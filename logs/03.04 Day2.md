《迈进游戏开发的大门》
* 分享：邹春毅
* 内容：游戏开发宏观介绍、游戏引擎介绍、渲染基础知识介绍、小品产品展示

* - [x] 课程 1：《设置项目》
    - [x] 1. 设置 UnityEditor
    - [x] 2. 创建项目
    - [x] 3. 导入资源
    - [x] 4. UnityEditor 界面
         * Project 窗口列出了当前项目中包含的所有文件和目录。这些文件包括项目中使用的所有图像、声音、3D 模型和其他项。所有这些统称为资源。
         * Console 窗口显示游戏正在产生的警告和错误，并可能提供修复这些错误的有用信息。默认情况下，Console 窗口选项卡位于 Project 窗口选项卡旁边。您可以移动 Console 窗口选项卡，通过拖放该选项卡将窗口停靠在 Project 窗口旁边。
         * Hierarchy窗口，在 Unity 中，游戏由场景组成。可将场景视为游戏的一个关卡或是另一个环境。在每个场景中都有一个对象列表，这些对象（例如，角色和景物）在该场景中都有一个相应的位置。这些对象在 Unity 中称为游戏对象 (GameObject)。
         * Scene 视图是一个实时的预览窗口。该视图显示当前加载的场景以及 Hierarchy 窗口中的所有游戏对象。您可以使用此窗口在场景中放置和移动游戏对象。在 Scene 视图中单击某个游戏对象将在 Hierarchy 窗口中突出显示该游戏对象。 
         * Game 窗口：默认情况下，Game 视图隐藏为 Scene 视图旁边的选项卡。Scene 视图允许您移动游戏对象并环顾整个场景，而 Game 视图会显示玩家在玩游戏时看到的内容。这取决于场景中的摄像机看到的内容。
         * 在另一个窗口中选择一个游戏对象时，Inspector 窗口将显示与该对象有关的所有数据。Unity 使用对象-组件模型，这意味着您可以向游戏对象添加不同的组件以改变其功能。例如，Camera 组件允许玩家观察场景。 
         * 所有游戏对象都是从一个 Transform 组件开始的，这个组件可用于指定游戏对象在场景中的位置和旋转。其他组件是可选的，您可以根据需要添加这些组件。 
    - [x] 5. 工具栏和导航 UI
           * 可能需要记住的快捷键是用于聚焦所选对象的 F 键。如果忘记了游戏对象在场景中的位置，只需在 Hierarchy 中选择该游戏对象，将光标移到 Scene 窗口上，然后按 F 键使该游戏对象在 Scene 窗口中居中。 
           * 在 Scene 窗口中时，您还可以：
             * 单击鼠标左键以在场景中选择您的游戏对象。
             * 单击鼠标中键并拖动以使用手形工具移动 Scene 视图的摄像机。
             * 单击鼠标右键并拖动以使用飞越模式（手形工具的一种变体）旋转 Scene 视图的摄像机。在执行此操作时，还可以使用 A 和 D 键左右移动摄像机，使用 W 和 S 键前后移动摄像机，使用 Q 和 E 键上下移动摄像机。
    - [x] 6. 布局
      * 默认布局
        * Unity Editor 可以采用多种布局方式。每种布局都有其自身的优势，您需要了解哪种布局最适合您。
        * 要切换布局，请选择 Window > Layouts（或使用 Editor 右上角的 Layouts 下拉菜单）。您可以从以下布局中选择：
      * 2 by 3 通过此布局可以同时看到 Scene 视图和 Game 视图并在右侧的列中看到 Inspector、Project 视图和 Hierarchy。
      * 4 Split 此布局适合从不同角度查看 3D 模型。
      * Tall 此布局使 Scene 视图和 Inspector 清晰美观。
      * Wide 此布局将 Hierarchy、Project 窗口和 Assets 推到 Editor 的底部。
      * Default 此布局使 Scene 视图或 Game 视图占据大部分 Editor 空间，还有空间用于两侧的 Assets、Hierarchy 和 Inspector。  这完全取决于个人喜好。所有 John Lemon’s Haunted Jaunt 教程都使用 Default 布局，并且 Console 窗口停靠在 Project 窗口的侧边（如本教程的“Console 窗口”部分所示）。

* - [x] 课程 2：《玩家角色：第1部分》
    - [x] 1. 保存场景 
    - [x] 2. 添加角色模型
         * 在 3D 游戏中看到的大多数都是模型，包括角色、环境和道具。这些通常是在 Unity 外部创建的，然后将它们导入并赋予相应的功能以制作游戏。为了使用这些模型，需要将它们添加为游戏对象（这称为创建模型的实例）。 
         * 一个 Transform 组件，这意味着该游戏对象在场景中具有位置和大小
         * 一个 Animator 组件，这意味着该游戏对象可以动画化
         * 此游戏对象包含一个名为 Skinned Mesh Renderer（带蒙皮的网格渲染器）的组件。正是这个组件可让您看到角色。 模型由一个包含三角形的网格组成，该网格由 Mesh Renderer（网格渲染器）进行“渲染”，从而使该网格可见。Skinned Mesh Renderer 是一种特殊类型的 Mesh Renderer，可让网格根据模型所有骨骼的位置和旋转来改变形状。这些骨骼是模型的子游戏对象 — JohnLemon 的骨骼是 Root 游戏对象的所有子项 
         * JohnLemon 在本质上形成动画的方式如下：角色父游戏对象上的 Animator 组件将改变所有骨骼游戏对象 Transform 组件的旋转，这些改变将一起发生以形成角色的动画。   
         * **退出播放模式时，在播放模式下所做的任何更改都不会保存。   **
    - [x] 3. 什么是预制体？
         * 预制件是一种特殊类型的资源，代表已设置组件的一个游戏对象或一组游戏对象。预制件就像一个蓝图，可用于轻松创建同一对象的实例。预制件的每个实例都关联到预制件资源，因此更改这个资源将更改所有场景中的所有预制件版本。   
         * 在项目中，这种机制的第一个用途是让角色成为预制件。这意味着，如果您继续为游戏制作多个关卡，则无需为每个关卡重新制作 JohnLemon，只需实例化一个新的预制件即可。
         * 预制件可以在 Hierarchy 窗口中通过其蓝色名称和图标加以识别 
         * 在 Unity 中，模型的工作方式与只读预制件类似。它们是用于为该模型创建实例的蓝图，但是蓝图本身无法更改。   
    - [x] 4. 将角色转化为预制体?
         * 为了使项目保持井然有序，将所有预制件保存在 Prefabs 文件夹中会很有帮助。   
         * 为了更改预制件，需要打开预制件以在预制件模式下进行编辑。在执行该操作之前，请按 Ctrl + S (Windows) 或 Cmd + S (macOS) 保存场景。
         * 禁用 Auto Save 复选框（启用此复选框会降低速度）。这种情况下将出现一个 Save 按钮，可以手动保存对预制件所做的任何更改。 
         *  在这里的整个 3D Beginner 项目中，您将编辑预制件，而且大多数情况下，您将进入预制件模式来进行此操作。习惯于在场景中编辑游戏对象与编辑预制件之间切换是使用 Unity 的核心操作。 
    - [x] 5. 动画化你的角色
         * 选择 JohnLemon 游戏对象，然后在 Inspector 中查看其 Animator 组件。第一个属性称为 Controller。它引用了一种称为 Animator Controller 的资源类型，您将使用这种资源来移动 JohnLemon。
         * Animator Controller 有一个状态机用于确定 Animator 组件在任何给定时间应该为其层级视图设置的动画。该动画基于事先在 Animator Controller 上设置的动画剪辑。
    - [x] 6. 创建 Animator Controller
         * Animator 窗口有两个主要部分：
           * 左侧有一个面板用于编辑 Animator 层 (Layers) 和 Animator 参数 (Parameters)
           * 右侧有一个区域显示状态机本身
         * Animator Controller 的状态机根据其 Animator 参数的当前值进行决策。这些 Animator 参数具有由脚本设置的值。每个独立变量都需要一个参数以用于影响角色正在播放的动画。
         *  JohnLemon 将具有两段动画：一段是不移动时的空闲动画玩家，另一段是移动时的行走动画。因此该角色可能处于两种状态：行走或不行走。   
    - [x] 7. 设置动画 
    - [x] 8. 创建 Animator 过渡 
    - [x] 9. 向过渡添加条件 
    - [x] 10. 将 Animator Controller 分配给 John Lemon 
    - [x] 11. 使角色对物理产生反应
          * Rigidbody 组件将游戏对象标记为可移动的物理系统的一部分。由于您肯定希望角色能够移动并且我们希望其撞到墙壁（因此成为物理系统的一部分），因此 JohnLemon 游戏对象需要一个 Rigidbody 组件。   
    - [x] 12. 什么是根运动（Root Motion）？
          * 动画用于在特定层级视图中移动和旋转所有游戏对象。这些移动和旋转大多数都是相对于其父项完成的，但是层级视图的父游戏对象没有父项，因此它们的移动不是相对的。此父游戏对象也可以称为根 (Root)，因此其移动称为根运动 (Root Motion)。
          * 重要注意事项！在 JohnLemon 预制件的层级视图中称为根的游戏对象指的是其骨架的根，而不是实际的根游戏对象。根游戏对象是 Animator 组件所在的任何游戏对象，在本例中，该游戏对象称为 JohnLemon。
          * 在 Animator 组件上启用了 Apply Root Motion，因此根在动画中的任何移动都将应用于每一帧。由于 Animator 正在播放 Idle 动画，没有移动，因此 Animator 不会施加任何动作。那么，为什么 JohnLemon 游戏对象会移动呢？这是因为 Animator 的更新模式 (Update Mode)。
    - [x] 13. 什么是更新循环？ 
          * 游戏的工作方式与电影和电视类似：一幅图像显示在屏幕上，该图像每秒变化多次，给人以运动的感觉。我们称这些图像为帧；将这些帧绘制到屏幕上的过程称为渲染。对于电影和电视，通常会预先定义要在屏幕上显示的下一幅图像，但是在游戏中，下一幅图像可能会发生巨大变化，因为用户会对接下来发生的事情产生影响。每幅图像都需要根据用户输入进行计算 — 由于这种变化可能在转瞬间发生，因此计算显示内容的程序要以同样快的速度进行运算。这称为更新循环。
          * 每次显示帧时，都会依序发生许多事情。您现在只需要知道，自定义组件的 Update 方法被调用后，会在屏幕上渲染新图像。这些更新的长度会有所不同，具体取决于计算和渲染的复杂程度。但是，还有另一个单独的循环可以运行所有物理操作。此循环不会改变更新的频率，因此称为 FixedUpdate。
          * Animator 组件可以更改其执行更新的时间。默认情况下根据渲染执行此更新。这意味着 Animator 在 Update 中移动角色，而 Rigidbody 同时在 Fixed Update 中移动角色。这就是造成您的问题的原因，很容易解决！
    - [x] 14. 修复 John Lemon 的移动问题 
    - [x] 15. Unity 中的坐标 
    - [x] 16. 位置和旋转 
    - [x] 17.  向 John Lemon 添加碰撞体 
    - [x] 18. 总结

- - [ ] 课程 3：《玩家角色：第 2 部分》 

  - [x] 1. 玩家角色（续）
       * 您将为此项目编写的所有脚本均采用 MonoBehaviour 的形式。MonoBehaviour 是特殊类型的脚本，可以像组件一样附加到游戏对象。这是因为它们是您可以自己编写的特定组件实例。 

  - [x] 2. 创建你的第一个脚本（PlayerMovement） 

    * 要用作组件的脚本在资源上的名称必须与脚本本身中的类名称相同。Unity 创建脚本文件时，会为其提供一个与该资源最初命名的名称相匹配的类名称。但是，重命名资源时，类名称不会更改。

  - [x] 3. 为水平轴和垂直轴创建变量 

    * Unity 有一个输入管理器用来定义可按名称找到的各种按钮和轴。例如，其中有一个称为 Horizontal 的轴，由 A 和 D 键以及向左和向右键表示。因此，通过该检查，玩家的计算机可以决定角色应该向左还是向右移动。
    * Input 和 GetAxis 之间的句点允许计算机访问上一个对象内的某些内容（GetAxis 是 Input 中的一个方法，因此为了从 Input 访问到 GetAxis，此处使用一个句点）。  

  - [x] 4. 你的如何创建变量的？ 

  - [x] 5. 创建矢量 
       * 在此项目中，您将使用 Unity 的内部命名约定。所有变量均以小写字母开头，但随后的单词以大写字母开头（这称为 camelCase）。 
       * 例外情况是非公共成员变量，这种变量以 m_ 前缀开头，所有单词均以大写字母开头（这称为 PascalCase）。成员变量是属于类而不是属于特定方法的变量。非公共成员变量的 m_ 部分起源于它们是“成员 (member)”变量。 

  - [x] 6. 设置变量的值 

  - [x] 7. 设置 Animator 组件 

  - [x] 8. 创建一个变量来存储对 Animator 组件的引用 
       * 静态方法是在类的类型上调用而不是在该类的实例上调用的方法。因为输入更大程度上是全局概念，所以不需要为了确定轴值而实现 Input 类的单个实例。鉴于这样的原因，用来获得这些值的方法已被设为静态。同样，Mathf 类中有很多 helper 方法（用于帮助另一个方法执行其任务的方法）不涉及 Mathf 特定实例的任何特定数据，因此这些方法也已设为静态。 
       * 但是，请考虑一下 m_Movement 变量。您需要设置该特定 Vector3 实例特有的值，因此这些方法不是静态的。要记住的重要一点是，需要使用类型名称调用静态方法，而使用实例名称调用非静态方法（或“实例”方法）。 

  - [x] 9. 获取对 Animator 组件的引用 

  - [x] 10. 设置对 Animator 组件的引用 
        * 添加尖括号的原因是 GetComponent 方法为泛型。泛型方法具有两组不同的参数：普通参数和类型参数。尖括号之间列出的参数是类型参数。 

  - [x] 11. 为角色创建旋转

        * 此代码创建一个名为 desiredForward 的 Vector3 变量。

        - 该变量设置为名为 RotateTowards 的方法的返回值，这个方法是 Vector3 类中的一个静态方法。RotateTowards 接受四个参数：前两个是 Vector3，分别是旋转时背离和朝向的矢量。   
        - 该代码以 transform.forward 开头，目标是 m_Movement 变量。transform.forward 是访问 Transform 组件并获取其前向矢量的快捷方式。   
        - 接下来的两个参数是起始矢量和目标矢量之间的变化量：首先是角度变化（以弧度为单位），然后是大小变化。此代码中的角度变化为 turnSpeed * Time.deltaTime，而大小变化为 0。
        - 为什么turnSpeed乘以Time.deltaTime？每帧都会调用一次 Update 方法，如果您的游戏以 60 帧/秒的速度运行，则意味着该方法将在一秒钟内被调用 60 次。每次调用都会有很小的变化，这样在 60 帧内您可以得到想要的一秒钟内的变化。但是，以 30 帧/秒的速度运行的游戏呢？只有一半的方法调用将在同一时间进行，因此只会发生一半的旋转。您不希望每秒的帧数影响角色的旋转速度，因为这是不对的！ 

  - [x] 12. 调整 turnSpeed 变量
        * turnSpeed 变量是您希望角色每秒旋转的角度（以弧度为单位）。然后，此变量乘以 Time.deltaTime 即可得出角色在此帧应旋转的量。弧度是角度的另一种度量方式；与度相似，但更自然。一个圆为 2π 弧度，即大约为 6 弧度。您的角色总是选取最短的旋转长度，因此，角色转过的最大角度约为 3 弧度。
        * 据此可知，turnSpeed 为 3 意味着角色转一整圈大约需要一秒钟。这样的速度实际上很慢。turnSpeed 为 6 意味着转一圈大约需要半秒，这仍然很慢。让我们尝试将值设置为 20，然后看看效果如何。如果需要，稍后随时可以更改此值。

  - [x] 13. 将移动和旋转应用于角色 

  - [x] 14. 移动 
        * Animator 的 deltaPosition 是由于可以应用于此帧的根运动而导致的位置变化。您将其大小（即长度）乘以我们希望角色移动的实际方向上的移动向量。 

  - [x] 15. 旋转 

  - [x] 16. 更新你的 Update 方法 
        * 在上一教程中，您了解了 Update 循环（用于渲染）和 FixedUpdate 循环（用于运行[物理操作）。您已经确保 Animator 通过物理循环适时运行，从而避免物理与动画之间发生冲突。但是，现在您将使用 OnAnimatorMove 来覆盖根运动。这意味着 OnAnimato](https://learn.unity.com/tutorial/the-player-character-part-1)rMove 实际上将通过物理适时被调用，而不是像 Update 方法那样通过渲染被调用。 
        * 这是 Unity 自动调用的另一个特殊方法，但是这个方法是通过物理适时调用的。FixedUpdate 不是在每个渲染的帧之前被调用，而是在物理系统处理所有碰撞和其他已发生的交互之前被调用。默认情况下，每秒正好调用 50 次这个方法。 

  - [x] 17. 测试所做的更改 

  - [x] 18. 调整 Game 视图设置 

  - [x] 19. 总结

- - [x] 课程 4：《环境》
  - [x] 1. 添加环境 
       * 在 Unity 中构建环境是一个根据制作的游戏类型不同而有所差异的过程。通常，这个过程涉及到将多个模型从 Project 窗口拖到 Hierarchy 窗口来实例化这些模型。环境通常需要在场景中有物理存在，因此随后要向每个模型添加碰撞体。这些部件通常是预制件，因此您不必每次都添加新的碰撞体。 
  - [x] 2. 为环境设置光照 
       * Unity 中的光源只是添加了 Light 组件的游戏对象。光源组件包含一些设置可用于更改光源的颜色和强度，还有光源的“类型”以及各种用于阴影和光照贴图 (Lightmapping) 的更复杂的控制。
       * Unity 中的每个新场景都分配了方向光 (Directional Light)，这是默认创建的两个游戏对象之一。您的场景现在还具有由关卡预制件 (Level Prefab) 添加的一系列额外光源。
  - [x] 3. 更改场景中的方向光 
  - [x] 4. 创建全局光照之光照贴图（Global Illumination Lightmapping）效果
       * Unity 中有两种光照可以帮助您模拟真实的光照行为：直接 (Direct) 光照和间接 (Indirect) 光照。直接光照来自特定的光源，例如太阳（场景中的方向光）。间接光照是当直射光从表面反弹时产生的额外光照。
       * 光照贴图可以模拟场景中的光反弹，并将其写入（即“烘焙”）到项目中存储的资源。这个过程需要时间，但可以产生十分逼真的场景。 
       * Lighting Settings 窗口是 Unity 全局光照功能针对当前加载的场景提供的主要控制点。窗口中还包含环境光照 (Environment Lighting)、反射 (Reflections) 和雾效 (Fog) 的设置     
  - [x] 5. 添加导航网格 
       * 为了帮助我们的幽灵寻路，Unity 内置了一个称为 NavMesh（即导航网格 (Navigation Mesh) 的缩写）的系统。在第二个教程中，您学习过“网格”是一组三角形的集合，这些三角形全部组合在一起以定义某个形状。这个网格使 JohnLemon 可以渲染到屏幕上。导航网格 (NavMesh) 是在地面上不可见的形状，定义了一个可以让选定游戏对象在其中移动的区域。 
       * 当某个游戏对象标识为 Static 时，Unity 的导航系统会认为该游戏对象不会移动。游戏环境由许多游戏对象和许多 Mesh Renderer（网格渲染器）组件组成。来自 Mesh Renderer 组件（其游戏对象被标记为 Static）的所有网格将组合构成导航网格的基础。
       * 您可能已经注意到，您是在场景中而不是在关卡预制件 (Level Prefab) 中进行这些更改；您将覆盖此预制件的设置而不是对其进行更改。当您希望对标准模板进行少量更改时，这非常有用。  
  - [x] 6. 创建导航网格 
       * 烘焙设置 (Bake settings) 控制如何构造导航网格的细节。第一组设置适用于穿梭于导航网格中的代理（游荡的精灵）：导航网格代理 (NavMesh Agents)。这些设置专门用于设置代理的尺寸以及代理可以穿越的地形。
       * 导航网格仅在 Navigation 窗口打开且处于活动状态时才可见（如果切换到 Inspector 选项卡，则网格将从 Scene 视图中消失）。不用担心，即使看不到导航网格，它仍然存在！    
  - [x] 7. 总结
* - [x] 课程 5：《摄像机》
    - [x] 1. 探索 Camera 组件 
         * 制作游戏时，有几种选择可确保摄像机跟随玩家角色。一种解决方案是为此编写一段脚本。但是，Unity 具有针对该问题的内置解决方案：Cinemachine。 
    - [x] 2. Cinemachine 的工作原理
         * Cinemachine 是 Unity 针对游戏中与摄像机有关的所有问题的解决方案。该系统简单总结如下：
           - 在场景中创建一个或多个“虚拟”摄像机。
           - 这些虚拟摄像机由一个名为 Cinemachine Brain 的组件进行管理。
           - Cinemachine Brain 与 Camera 组件连接到相同的游戏对象，默认情况下，这个游戏对象将是 Main Camera 游戏对象。
           - Cinemachine Brain 管理所有虚拟摄像机，并确定实际摄像机应跟随哪个虚拟摄像机（或虚拟摄像机的组合）。
         * 在您的游戏中，摄像机只会跟随 JohnLemon，因此您只需要一个虚拟摄像机。您将确保此虚拟摄像机跟随 JohnLemon，然后 Main Camera 游戏对象会连接到这个虚拟摄像机。
    - [x] 3. 使用 Cinemachine 设置虚拟摄像机
    - [x] 4. 更改 Cinemachine Virtual Camera 组件设置 
    - [x] 5. 添加后期处理效果
         * 后期处理涉及在游戏图像渲染到屏幕上之前对其应用滤镜和效果（类似于可以添加到照片的滤镜）。
         * 后期处理效果组是称为后期处理配置文件 (Post-processing Profiles) 的资源。分配了配置文件的游戏世界区域是称为后期处理体积 (Post Process Volumes) 的组件。  
         * 有时，不同的摄像机具有不同的后期处理。为了将一个处理效果组链接到特定摄影机，需要将 Post Process Layer 组件添加到与 Camera 组件相同的游戏对象。层 (Layer) 是一种按行为组织游戏对象的方法。 
    - [x] 6. 创建后共用处理层（Post-Processing Layer） 
    - [x] 7. 通过抗锯齿（Anti-aliasing）改善图像质量 
         * 抗锯齿是一种后期处理效果，会使用中间色调的像素将这些锯齿状线条包围起来，从而可以降低锯齿明显程度。有几种不同的算法可以计算出需要调整哪些像素以及调整多少，然后您将使用最简单、最有效的一种。 
         * Fast Approximate Anti-aliasing (FXAA) 
    - [x] 8. 创建后期处理体积（Post-Processing Volume） 
         * 该游戏对象将成为您的全局后期处理体积。全局体积将作为受影响的摄像机的默认配置文件。然后，其他非全局体积可以覆盖此体积的效果，但是您的游戏将不需要任何其他体积。   
    - [x] 9. 添加颜色分级(Color Grading)效果
         * 颜色分级用于更改被渲染视图的亮度、对比度和颜色。该功能类似于在照片编辑软件或 Instagram 中应用滤镜。为了让您的游戏看起来更加诡异，您将调整被渲染视图的颜色和亮度级别。 
         * 注意：该组件中的设置是配置文件资源的快捷方式；对 Overrides 细分部分进行的所有更改都将更改配置文件资源，并且不会直接影响该组件
         * 色调映射会更改最终渲染帧的输出，以便更轻松地控制光源和阴影。   
         * ACES 色调映射是应用色调映射的行业标准方法。这种色调映射有助于为您的项目创建更具电影质感的外观效果。   
         *  启用每个轨迹球 (Trackball) 下的 Lift、Gamma 和 Gain 复选框。 Lift 会影响阴影的颜色，Gain 会更改最亮的高光，而 Gamma 涵盖图像颜色中间（或中间范围）的所有内容。  
    - [x] 10. 添加泛光（Bloom）效果
          * 一种使一些角落和裂缝变暗的好方法是使用环境光遮挡 (Ambient Occlusion) 效果。环境光遮挡使光线未到达的较局促角落变暗，由此模仿这些区域的现实效果。 
    - [x] 11. 添加环境光遮挡 (Ambient Occlusion) 效果 
    - [x] 12. 添加渐晕 (Vignette) 效果 
    - [x] 13. 添加镜头失真 (Lens Distortion) 效果 
    - [x] 14. 总结

* - [x] 课程 6：《结束游戏》
    - [x] 1. 设置 UI
       * 当 JohnLemon 到达出口时，游戏应该淡出并退出，但是您需要注意这一点：在 Unity Editor 中退出和在游戏的最终构建版本中退出是不同的。 
    - [x] 2. 配置画布 (Canvas) 
         * 属于 UI 系统的游戏对象需要更好地控制其位置，因此具有 Rect Transform 组件。对于位于 UI 层级视图根部的 Canvas，Rect Transform 设置为只读。
         * Canvas 组件可以控制如何渲染属于该 Canvas 的 UI 元素。此渲染主要由 Render Mode 设置进行控制。  渲染具有三种可能的模式： 
             * Screen Space - Overlay，在这种模式下，画布将填充屏幕，画布的所有 UI 元素都会渲染在其他所有元素之上 
             * Screen Space - Camera，在这种模式下，画布将填充屏幕，但会渲染到特定摄像机，并受到与摄像机的距离的影响  
             * World Space，在这种模式下，UI 存在于场景中，并渲染到其他对象的前面或后面（例如，3D 世界中角色上方的名称标签）  
    - [x] 3. 拉伸图像 
    - [x] 4. 探索 Rect Transform 组件
         * 一个 3D 游戏对象的位置由该游戏对象的单个轴心点表示。该轴心点在 Transform 组件中的位置是相对于游戏对象的父对象的位置。Rect Transform 组件的工作原理类似，但是由于 UI 元素可以表示一个区域，因此存在一些差异。Rect Transform 组件的位置不是相对于其父对象上的单个轴心点，而是相对于其父对象的一个区域。父对象的此区域由 Rect Transform 的锚点表示。
         * UI 元素的位置以像素为单位。这非常重要，特别是因为并非所有屏幕的像素数都相同。这便是锚点系统如此强大的原因：当锚点全部在一起并且显示一个点时，Rect Transform 将以像素为单位显示 UI 元素从该点偏移的位置。   
    - [x] 5. 配置 Rect Transform 组件 
         * 锚点是相对于其父级的：0 表示屏幕的最左侧或底部，1 表示屏幕的最右侧或顶部。 
    - [x] 6. 添加获胜图像 
    - [x] 7. 添加 Canvas Group 组件 
    - [x] 8. 创建 GameEnding 触发器 
    - [x] 9. 创建新脚本 
    - [x] 10. 启动 GameEnding 脚本 
    - [x] 11. 添加 Update 方法 
    - [x] 12. 编写 if 语句代码块 
          * 这里有一些重要的知识需要了解。该方法确实可以退出游戏，但仅适用于完全构建的应用程序。目前，该游戏只是在 Editor 中播放的一个项目，因此尚无任何作用。在本系列的最后一个教程中，您将构建自己的游戏；完成此操作后，代码行将正常运行。在此之前，您将需要像以前一样退出播放模式。  
    - [x] 13. 设置 GameEnding 脚本的变量 
    - [x] 14. 总结

  - [ ] 课程 7：《敌人，第 1 部分：静态 Observer》
    - 设置石像鬼 (Gargoyle) 预制件 
    - 动画化石像鬼 
    - 向石像鬼添加碰撞体
    - 创建触发器以模拟石像鬼的视线
    - 编写自定义 Observer 脚本 
    - 添加一个类以检测玩家的角色 
    - 检查敌人的视线是否清晰 
    - 修改 GameEnding 脚本 
    - 创建两种结束关卡的方式 
    - 允许玩家重新开始关卡 
    - 完善您的石像鬼 (Gargoyle) 预制件 
    - 总结